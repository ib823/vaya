//! AUTO-GENERATED FROM vaya-common
//! DO NOT EDIT MANUALLY - Changes will be overwritten
//!
//! Generated by: vaya_common::codegen::generate_frontend_types
//! Source: crates/vaya-common/src/types.rs

#![allow(dead_code)]

use serde::{Deserialize, Serialize};

// ============================================================================
// IATA CODE
// ============================================================================

/// Airport/City Code (3-4 chars)
/// WASM-compatible version of vaya_common::IataCode
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct IataCode(pub String);

impl IataCode {
    /// Create a new IATA code from a string
    pub fn new(code: &str) -> Self {
        Self(code.to_uppercase())
    }

    /// Get the code as a string slice
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Check if this is a valid 3-letter IATA code
    pub fn is_valid(&self) -> bool {
        self.0.len() == 3 && self.0.chars().all(|c| c.is_ascii_uppercase())
    }
}

impl std::fmt::Display for IataCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Default for IataCode {
    fn default() -> Self {
        Self(String::new())
    }
}

/// Common airport constants
pub mod airports {
    use super::IataCode;
    pub fn kul() -> IataCode { IataCode::new("KUL") }
    pub fn sin() -> IataCode { IataCode::new("SIN") }
    pub fn bkk() -> IataCode { IataCode::new("BKK") }
    pub fn nrt() -> IataCode { IataCode::new("NRT") }
    pub fn hnd() -> IataCode { IataCode::new("HND") }
    pub fn hkg() -> IataCode { IataCode::new("HKG") }
    pub fn icn() -> IataCode { IataCode::new("ICN") }
    pub fn syd() -> IataCode { IataCode::new("SYD") }
    pub fn mel() -> IataCode { IataCode::new("MEL") }
    pub fn lhr() -> IataCode { IataCode::new("LHR") }
    pub fn cdg() -> IataCode { IataCode::new("CDG") }
    pub fn dxb() -> IataCode { IataCode::new("DXB") }
    pub fn jfk() -> IataCode { IataCode::new("JFK") }
    pub fn lax() -> IataCode { IataCode::new("LAX") }
}

// ============================================================================
// CURRENCY CODE
// ============================================================================

/// Currency Code (3 chars, ISO 4217)
/// WASM-compatible version of vaya_common::CurrencyCode
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct CurrencyCode(pub String);

impl CurrencyCode {
    pub fn new(code: &str) -> Self {
        Self(code.to_uppercase())
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Get decimal places for this currency
    pub fn decimals(&self) -> u8 {
        match self.0.as_str() {
            "JPY" | "KRW" | "VND" => 0,
            "BHD" | "KWD" | "OMR" => 3,
            _ => 2,
        }
    }
}

impl std::fmt::Display for CurrencyCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Default for CurrencyCode {
    fn default() -> Self {
        Self("MYR".to_string())
    }
}

/// Common currency constants
pub mod currencies {
    use super::CurrencyCode;
    pub fn myr() -> CurrencyCode { CurrencyCode::new("MYR") }
    pub fn usd() -> CurrencyCode { CurrencyCode::new("USD") }
    pub fn sgd() -> CurrencyCode { CurrencyCode::new("SGD") }
    pub fn thb() -> CurrencyCode { CurrencyCode::new("THB") }
    pub fn idr() -> CurrencyCode { CurrencyCode::new("IDR") }
    pub fn php() -> CurrencyCode { CurrencyCode::new("PHP") }
    pub fn vnd() -> CurrencyCode { CurrencyCode::new("VND") }
    pub fn jpy() -> CurrencyCode { CurrencyCode::new("JPY") }
    pub fn krw() -> CurrencyCode { CurrencyCode::new("KRW") }
    pub fn cny() -> CurrencyCode { CurrencyCode::new("CNY") }
    pub fn hkd() -> CurrencyCode { CurrencyCode::new("HKD") }
    pub fn twd() -> CurrencyCode { CurrencyCode::new("TWD") }
    pub fn aud() -> CurrencyCode { CurrencyCode::new("AUD") }
    pub fn nzd() -> CurrencyCode { CurrencyCode::new("NZD") }
    pub fn eur() -> CurrencyCode { CurrencyCode::new("EUR") }
    pub fn gbp() -> CurrencyCode { CurrencyCode::new("GBP") }
}

// ============================================================================
// PRICE
// ============================================================================

/// Price with currency - the standard money type
/// WASM-compatible version of vaya_common::Price
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Price {
    /// Amount in minor units (cents/sen)
    pub amount: i64,
    /// Currency code
    pub currency: String,
}

impl Price {
    pub fn new(amount: i64, currency: &str) -> Self {
        Self {
            amount,
            currency: currency.to_string(),
        }
    }

    /// Create price in MYR (sen)
    pub fn myr(sen: i64) -> Self {
        Self::new(sen, "MYR")
    }

    /// Create price in USD (cents)
    pub fn usd(cents: i64) -> Self {
        Self::new(cents, "USD")
    }

    /// Get display amount (major units)
    pub fn display_amount(&self) -> f64 {
        let decimals = match self.currency.as_str() {
            "JPY" | "KRW" | "VND" => 0,
            "BHD" | "KWD" | "OMR" => 3,
            _ => 2,
        };
        self.amount as f64 / 10f64.powi(decimals)
    }

    /// Format for display (e.g., "RM 150.00")
    pub fn format(&self) -> String {
        let symbol = match self.currency.as_str() {
            "MYR" => "RM",
            "USD" => "$",
            "SGD" => "S$",
            "EUR" => "€",
            "GBP" => "£",
            "JPY" => "¥",
            "CNY" => "¥",
            "THB" => "฿",
            _ => &self.currency,
        };
        format!("{} {:.2}", symbol, self.display_amount())
    }

    /// Check if zero
    pub fn is_zero(&self) -> bool {
        self.amount == 0
    }
}

impl std::fmt::Display for Price {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.format())
    }
}

impl Default for Price {
    fn default() -> Self {
        Self::myr(0)
    }
}

// ============================================================================
// DATE
// ============================================================================

/// Date (year, month, day) - compact date without time
/// WASM-compatible version of vaya_common::Date
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Date {
    pub year: i32,
    pub month: u8,
    pub day: u8,
}

impl Date {
    pub fn new(year: i32, month: u8, day: u8) -> Self {
        Self { year, month, day }
    }

    /// Parse from ISO 8601 date string (YYYY-MM-DD)
    pub fn parse(s: &str) -> Option<Self> {
        let parts: Vec<&str> = s.split('-').collect();
        if parts.len() != 3 {
            return None;
        }
        Some(Self {
            year: parts[0].parse().ok()?,
            month: parts[1].parse().ok()?,
            day: parts[2].parse().ok()?,
        })
    }

    /// Check if valid date
    pub fn is_valid(&self) -> bool {
        if self.month < 1 || self.month > 12 || self.day < 1 {
            return false;
        }
        let days_in_month = match self.month {
            1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,
            4 | 6 | 9 | 11 => 30,
            2 => {
                if (self.year % 4 == 0 && self.year % 100 != 0) || (self.year % 400 == 0) {
                    29
                } else {
                    28
                }
            }
            _ => return false,
        };
        self.day <= days_in_month
    }

    /// Format as ISO 8601 string
    pub fn to_iso_string(&self) -> String {
        format!("{:04}-{:02}-{:02}", self.year, self.month, self.day)
    }
}

impl std::fmt::Display for Date {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_iso_string())
    }
}

impl Default for Date {
    fn default() -> Self {
        Self::new(2026, 1, 1)
    }
}

// ============================================================================
// ROUTE
// ============================================================================

/// Route (origin -> destination)
/// WASM-compatible version of vaya_common::Route
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Route {
    pub origin: String,
    pub destination: String,
}

impl Route {
    pub fn new(origin: &str, destination: &str) -> Self {
        Self {
            origin: origin.to_uppercase(),
            destination: destination.to_uppercase(),
        }
    }

    /// Check if valid (both codes are 3-letter IATA codes and different)
    pub fn is_valid(&self) -> bool {
        self.origin.len() == 3
            && self.destination.len() == 3
            && self.origin != self.destination
            && self.origin.chars().all(|c| c.is_ascii_uppercase())
            && self.destination.chars().all(|c| c.is_ascii_uppercase())
    }

    /// Get the reverse route
    pub fn reverse(&self) -> Self {
        Self {
            origin: self.destination.clone(),
            destination: self.origin.clone(),
        }
    }

    /// Format as "KUL-NRT"
    pub fn to_string_compact(&self) -> String {
        format!("{}-{}", self.origin, self.destination)
    }
}

impl std::fmt::Display for Route {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} → {}", self.origin, self.destination)
    }
}

impl Default for Route {
    fn default() -> Self {
        Self::new("KUL", "SIN")
    }
}

// ============================================================================
// TIMESTAMP
// ============================================================================

/// Unix timestamp (seconds since epoch)
/// WASM-compatible version of vaya_common::Timestamp
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Timestamp(pub i64);

impl Timestamp {
    pub const EPOCH: Self = Self(0);

    pub fn from_unix(secs: i64) -> Self {
        Self(secs)
    }

    pub fn as_unix(&self) -> i64 {
        self.0
    }

    /// Add seconds
    pub fn add_secs(&self, secs: i64) -> Self {
        Self(self.0.saturating_add(secs))
    }

    /// Add days
    pub fn add_days(&self, days: i64) -> Self {
        self.add_secs(days * 86400)
    }
}

impl std::fmt::Display for Timestamp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // Simple ISO 8601 formatting
        let secs = self.0;
        let days = secs / 86400;
        let time_of_day = secs % 86400;
        let hours = time_of_day / 3600;
        let minutes = (time_of_day % 3600) / 60;
        let seconds = time_of_day % 60;

        let mut y = 1970i64;
        let mut remaining_days = days;
        loop {
            let days_in_year = if (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0) { 366 } else { 365 };
            if remaining_days < days_in_year {
                break;
            }
            remaining_days -= days_in_year;
            y += 1;
        }

        write!(f, "{:04}-01-01T{:02}:{:02}:{:02}Z", y, hours, minutes, seconds)
    }
}

impl Default for Timestamp {
    fn default() -> Self {
        Self::EPOCH
    }
}

// ============================================================================
// UUID
// ============================================================================

/// UUID - Universally Unique Identifier
/// WASM-compatible version (uses string representation instead of ring)
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Uuid(pub String);

impl Uuid {
    pub const NIL: &'static str = "00000000-0000-0000-0000-000000000000";

    /// Create from string
    pub fn from_string(s: &str) -> Self {
        Self(s.to_string())
    }

    /// Check if this is the nil UUID
    pub fn is_nil(&self) -> bool {
        self.0 == Self::NIL
    }

    /// Get as string
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Generate a simple pseudo-random UUID (not cryptographically secure)
    /// For production, use a proper UUID library on the server side
    #[cfg(target_arch = "wasm32")]
    pub fn new_v4() -> Self {
        // Use JavaScript's crypto.getRandomValues in WASM
        use js_sys::{Math, Date};
        let timestamp = Date::now() as u64;
        let random = (Math::random() * 1e16) as u64;
        let uuid = format!(
            "{:08x}-{:04x}-4{:03x}-{:04x}-{:012x}",
            (timestamp >> 32) as u32,
            (timestamp >> 16) as u16,
            (random >> 48) as u16 & 0x0fff,
            ((random >> 32) as u16 & 0x3fff) | 0x8000,
            random & 0xffffffffffff
        );
        Self(uuid)
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn new_v4() -> Self {
        // Fallback for non-WASM targets
        Self(Self::NIL.to_string())
    }
}

impl std::fmt::Display for Uuid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Default for Uuid {
    fn default() -> Self {
        Self(Self::NIL.to_string())
    }
}

// ============================================================================
// AIRLINE CODE
// ============================================================================

/// Airline code (2-letter IATA)
/// WASM-compatible version of vaya_common::AirlineCode
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct AirlineCode(pub String);

impl AirlineCode {
    pub fn new(code: &str) -> Self {
        Self(code.to_uppercase())
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for AirlineCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Default for AirlineCode {
    fn default() -> Self {
        Self("MH".to_string())
    }
}

/// Common airline constants
pub mod airlines {
    use super::AirlineCode;
    pub fn mh() -> AirlineCode { AirlineCode::new("MH") }  // Malaysia Airlines
    pub fn ak() -> AirlineCode { AirlineCode::new("AK") }  // AirAsia
    pub fn sq() -> AirlineCode { AirlineCode::new("SQ") }  // Singapore Airlines
    pub fn tg() -> AirlineCode { AirlineCode::new("TG") }  // Thai Airways
    pub fn cx() -> AirlineCode { AirlineCode::new("CX") }  // Cathay Pacific
    pub fn nh() -> AirlineCode { AirlineCode::new("NH") }  // ANA
    pub fn jl() -> AirlineCode { AirlineCode::new("JL") }  // Japan Airlines
    pub fn ke() -> AirlineCode { AirlineCode::new("KE") }  // Korean Air
    pub fn oz() -> AirlineCode { AirlineCode::new("OZ") }  // Asiana
    pub fn ek() -> AirlineCode { AirlineCode::new("EK") }  // Emirates
    pub fn qr() -> AirlineCode { AirlineCode::new("QR") }  // Qatar Airways
    pub fn tr() -> AirlineCode { AirlineCode::new("TR") }  // Scoot
}

